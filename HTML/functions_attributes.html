<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Functions and attributes</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jyotishka Datta" />
    <script src="functions_attributes_files/header-attrs/header-attrs.js"></script>
    <link href="functions_attributes_files/remark-css/default.css" rel="stylesheet" />
    <link href="functions_attributes_files/remark-css/default-fonts.css" rel="stylesheet" />
    <link href="functions_attributes_files/font-awesome/css/all.css" rel="stylesheet" />
    <link href="functions_attributes_files/font-awesome/css/v4-shims.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Functions and attributes
]
.author[
### Jyotishka Datta
]
.date[
### updated: 2023-08-23
]

---





---
class: middle
count: false

# Functions

---

## Function Parts

Functions are defined by two components: the arguments (`formals`) and the code (`body`). Functions are assigned names like any other object in R (using `=` or `&lt;-`)


```r
gcd = function(long1, lat1, long2, lat2) {
  R = 6371 # Earth mean radius in km
  
  # distance in km
  acos(sin(lat1)*sin(lat2) + cos(lat1)*cos(lat2) * cos(long2-long1)) * R
}
```

---

## Returning values

There are two approaches to returning values from functions in R - explicit and implicit return values.

--

**Explicit** - using one or more `return` statements


```r
f = function(x) {
  x + 1
  return(x * x)
}
f(2)
```

```
## [1] 4
```

--

**Implicit** - return value of the last expression is returned.


```r
g = function(x) {
  x + 1
  x * x
}
g(3)
```

```
## [1] 9
```

---

## Returning multiple values

If we want a function to return more than one value we can group things using either vectors or lists.


```r
f = function(x) {
  c(x, x^2, x^3)
}

f(1:2)
```

```
## [1] 1 2 1 4 1 8
```


```r
g = function(x) {
  list(x, "hello")
}

g(1:2)
```

```
## [[1]]
## [1] 1 2
## 
## [[2]]
## [1] "hello"
```

---
class: split-50

## Argument names

When defining a function we are also implicitly defining names for the arguments, when calling the function we can use these names to pass arguments in a alternative order.



```r
f = function(x, y, z) {
  paste0("x=", x, " y=", y, " z=", z)
}
```

.pull-left[

```r
f(1, 2, 3)
```

```
## [1] "x=1 y=2 z=3"
```

```r
f(z=1, x=2, y=3)
```

```
## [1] "x=2 y=3 z=1"
```
]

.pull-right[

```r
f(y=2, 1, 3)
```

```
## [1] "x=1 y=2 z=3"
```

```r
f(y=2, 1, x=3)
```

```
## [1] "x=3 y=2 z=1"
```
]

--

.pad-top[


```r
f(1, 2, 3, 4)
```

```
## Error in f(1, 2, 3, 4): unused argument (4)
```

```r
f(1, 2, m=3)
```

```
## Error in f(1, 2, m = 3): unused argument (m = 3)
```

]
---

## Argument defaults

It is also possible to give function arguments default values, so that they don't need to be provided every time the function is called.


```r
f = function(x, y=1, z=1) {
  paste0("x=", x, " y=", y, " z=", z)
}
```

.pull-left[

```r
f(3)
```

```
## [1] "x=3 y=1 z=1"
```

```r
f(x=3)
```

```
## [1] "x=3 y=1 z=1"
```
]

.pull-right[

```r
f(z=3, x=2)
```

```
## [1] "x=2 y=1 z=3"
```

```r
f(y=2, 2)
```

```
## [1] "x=2 y=2 z=1"
```
]

--

.pad-top[

```r
f()
```

```
## Error in paste0("x=", x, " y=", y, " z=", z): argument "x" is missing, with no default
```
]

---

## Scope

R has generous scoping rules, if it can't find a variable in the functions body, it will look for it in the next higher scope, and so on.


```r
y = 1
f = function(x) {
  x + y
}

f(3)
```

```
## [1] 4
```

--

.pad-top[]


```r
y = 1
g = function(x) {
  y = 2
  x + y
}

g(3)
```

```
## [1] 5
```

---

Additionally, variables defined within a scope only persist for the duration of that scope, and do not overwrite variables at a higher scopes


```r
x = 1
y = 1
z = 1
f = function() {
    y = 2
    g = function() {
      z = 3
      return(x + y + z)
    }
    return(g())
}
f()
```

```
## [1] 6
```

```r
c(x,y,z)
```

```
## [1] 1 1 1
```

---

## Exercise 1 - scope

What is the output of the following code? Explain why.


```r
z = 1

f = function(x, y, z) {
  z = x+y

  g = function(m = x, n = y) {
    m/z + n/z
  }

  z * g()
}

f(1, 2, x = 3)
```

---

## Operators as functions

In R, operators are actually a special type of function - using backticks around the operator we can write them as functions.
 

```r
`+`
```

```
## function (e1, e2)  .Primitive("+")
```

```r
typeof(`+`)
```

```
## [1] "builtin"
```

--

.pad-top[]


```r
x = 4:1
x + 2
```

```
## [1] 6 5 4 3
```

```r
`+`(x, 2)
```

```
## [1] 6 5 4 3
```


---

## Getting Help

Prefixing any function name with a `?` will open the related help file for that function.


```r
?`+`
?sum
```

For functions not in the base package, you can generally see their implementation by entering the function name without parentheses (or using the `body` function).


```r
lm
```

```
## function (formula, data, subset, weights, na.action, method = "qr", 
##     model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, 
##     contrasts = NULL, offset, ...) 
## {
##     ret.x &lt;- x
##     ret.y &lt;- y
##     cl &lt;- match.call()
##     mf &lt;- match.call(expand.dots = FALSE)
##     m &lt;- match(c("formula", "data", "subset", "weights", "na.action", 
##         "offset"), names(mf), 0L)
##     mf &lt;- mf[c(1L, m)]
##     mf$drop.unused.levels &lt;- TRUE
##     mf[[1L]] &lt;- quote(stats::model.frame)
##     mf &lt;- eval(mf, parent.frame())
##     if (method == "model.frame") 
##         return(mf)
##     else if (method != "qr") 
##         warning(gettextf("method = '%s' is not supported. Using 'qr'", 
##             method), domain = NA)
##     mt &lt;- attr(mf, "terms")
##     y &lt;- model.response(mf, "numeric")
##     w &lt;- as.vector(model.weights(mf))
##     if (!is.null(w) &amp;&amp; !is.numeric(w)) 
##         stop("'weights' must be a numeric vector")
##     offset &lt;- model.offset(mf)
##     mlm &lt;- is.matrix(y)
##     ny &lt;- if (mlm) 
##         nrow(y)
##     else length(y)
##     if (!is.null(offset)) {
##         if (!mlm) 
##             offset &lt;- as.vector(offset)
##         if (NROW(offset) != ny) 
##             stop(gettextf("number of offsets is %d, should equal %d (number of observations)", 
##                 NROW(offset), ny), domain = NA)
##     }
##     if (is.empty.model(mt)) {
##         x &lt;- NULL
##         z &lt;- list(coefficients = if (mlm) matrix(NA_real_, 0, 
##             ncol(y)) else numeric(), residuals = y, fitted.values = 0 * 
##             y, weights = w, rank = 0L, df.residual = if (!is.null(w)) sum(w != 
##             0) else ny)
##         if (!is.null(offset)) {
##             z$fitted.values &lt;- offset
##             z$residuals &lt;- y - offset
##         }
##     }
##     else {
##         x &lt;- model.matrix(mt, mf, contrasts)
##         z &lt;- if (is.null(w)) 
##             lm.fit(x, y, offset = offset, singular.ok = singular.ok, 
##                 ...)
##         else lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, 
##             ...)
##     }
##     class(z) &lt;- c(if (mlm) "mlm", "lm")
##     z$na.action &lt;- attr(mf, "na.action")
##     z$offset &lt;- offset
##     z$contrasts &lt;- attr(x, "contrasts")
##     z$xlevels &lt;- .getXlevels(mt, mf)
##     z$call &lt;- cl
##     z$terms &lt;- mt
##     if (model) 
##         z$model &lt;- mf
##     if (ret.x) 
##         z$x &lt;- x
##     if (ret.y) 
##         z$y &lt;- y
##     if (!qr) 
##         z$qr &lt;- NULL
##     z
## }
## &lt;bytecode: 0x0000025a648cb840&gt;
## &lt;environment: namespace:stats&gt;
```

---

## Less Helpful Examples


```r
list
```

```
## function (...)  .Primitive("list")
```

```r
`[`
```

```
## .Primitive("[")
```

```r
sum
```

```
## function (..., na.rm = FALSE)  .Primitive("sum")
```

```r
`+`
```

```
## function (e1, e2)  .Primitive("+")
```


---
class: middle
count: false

# Attributes

---

## Attributes

Attributes are metadata that can be attached to objects in R. Some are special (e.g. `class`, `comment`, `dim`, `dimnames`, `names`, etc.) and change the way in which an object behaves in R.

--

Attributes are implemented as a named list that is attached to an object. They can be interacted with via the `attr` and `attributes` functions.


```r
(x = c(L=1,M=2,N=3))
```

```
## L M N 
## 1 2 3
```

--


```r
attributes(x)
```

```
## $names
## [1] "L" "M" "N"
```

```r
str(attributes(x))
```

```
## List of 1
##  $ names: chr [1:3] "L" "M" "N"
```

---


```r
attr(x, "names") = c("A","B","C")
x
```

```
## A B C 
## 1 2 3
```

--


```r
names(x)
```

```
## [1] "A" "B" "C"
```

```r
names(x) = c("Z","Y","X")
x
```

```
## Z Y X 
## 1 2 3
```

--

.pull-left[

```r
names(x) = 1:3
x
```

```
## 1 2 3 
## 1 2 3
```

```r
attributes(x)
```

```
## $names
## [1] "1" "2" "3"
```
]

.pull-right[

```r
names(x) = c(TRUE, FALSE, TRUE)
x
```

```
##  TRUE FALSE  TRUE 
##     1     2     3
```

```r
attributes(x)
```

```
## $names
## [1] "TRUE"  "FALSE" "TRUE"
```
]

---

## Factors

Factor objects are how R represents categorical data (e.g. a variable where there are a fixed # of possible outcomes).


```r
(x = factor(c("Sunny", "Cloudy", "Rainy", "Cloudy", "Cloudy")))
```

```
## [1] Sunny  Cloudy Rainy  Cloudy Cloudy
## Levels: Cloudy Rainy Sunny
```

--


```r
str(x)
```

```
##  Factor w/ 3 levels "Cloudy","Rainy",..: 3 1 2 1 1
```

--


```r
typeof(x)
```

```
## [1] "integer"
```

---

## Composition

A factor is just an integer vector with two attributes: `class = "factor"` and `levels`.


```r
x
```

```
## [1] Sunny  Cloudy Rainy  Cloudy Cloudy
## Levels: Cloudy Rainy Sunny
```

```r
attributes(x)
```

```
## $levels
## [1] "Cloudy" "Rainy"  "Sunny" 
## 
## $class
## [1] "factor"
```

--

We can build our own factor from scratch using,


```r
y = c(3L, 1L, 2L, 1L, 1L)
attr(y, "levels") = c("Cloudy", "Rainy", "Sunny")
attr(y, "class") = "factor"
y
```

```
## [1] Sunny  Cloudy Rainy  Cloudy Cloudy
## Levels: Cloudy Rainy Sunny
```

---

Knowning factors are stored as integers help explain some of their more interesting behaviors:


```r
x+1
```

```
## Warning in Ops.factor(x, 1): '+' not meaningful for factors
```

```
## [1] NA NA NA NA NA
```

```r
is.integer(x)
```

```
## [1] FALSE
```

```r
as.integer(x)
```

```
## [1] 3 1 2 1 1
```

```r
as.character(x)
```

```
## [1] "Sunny"  "Cloudy" "Rainy"  "Cloudy" "Cloudy"
```

```r
as.logical(x)
```

```
## [1] NA NA NA NA NA
```

---
class: middle
count: false

# S3 Object System

---

## `class`

The `class` attribute is an additional layer to R's type hierarchy,

&lt;br/&gt;



 value            |  `typeof()`      |  `mode()`      |  `class()`        
:-----------------|:-----------------|:---------------|:---------------
`TRUE`            | logical | logical | logical 
`1`               | double    | numeric    | numeric    
`1L`              | integer   | numeric   | integer   
`"A"`             | character  | character  | character  
`NULL`            | NULL | NULL | NULL 
`list(1, "A")`    | list    | list    | list  
`factor("A")`     | integer    | numeric    | factor  
`function(x) x^2` | closure    | function    | function  


---

## S3 class specialization


```r
x = c("A","B","A","C")
print( x )
```

```
## [1] "A" "B" "A" "C"
```

```r
print( factor(x) )
```

```
## [1] A B A C
## Levels: A B C
```

```r
print( unclass( factor(x) ) )
```

```
## [1] 1 2 1 3
## attr(,"levels")
## [1] "A" "B" "C"
```

--

.pad-top[]


```r
print
```

```
## function (x, ...) 
## UseMethod("print")
## &lt;bytecode: 0x0000025a5e202c60&gt;
## &lt;environment: namespace:base&gt;
```

---

## Other examples

.pull-left[

```r
mean
```

```
## function (x, ...) 
## UseMethod("mean")
## &lt;bytecode: 0x0000025a6017e6a8&gt;
## &lt;environment: namespace:base&gt;
```

```r
t.test
```

```
## function (x, ...) 
## UseMethod("t.test")
## &lt;bytecode: 0x0000025a5f708940&gt;
## &lt;environment: namespace:stats&gt;
```
]

.pull-right[

```r
summary
```

```
## function (object, ...) 
## UseMethod("summary")
## &lt;bytecode: 0x0000025a64f84240&gt;
## &lt;environment: namespace:base&gt;
```

```r
plot
```

```
## function (x, y, ...) 
## UseMethod("plot")
## &lt;bytecode: 0x0000025a64fe55c0&gt;
## &lt;environment: namespace:base&gt;
```
]

&lt;br/&gt;

Not all base functions use this approach,


```r
sum
```

```
## function (..., na.rm = FALSE)  .Primitive("sum")
```

---

## What is S3?

&lt;br/&gt;

&gt; S3 is R’s first and simplest OO system. It is the only OO system used in the base and stats packages, and it’s the most commonly used system in CRAN packages. S3 is informal and ad hoc, but it has a certain elegance in its minimalism: you can’t take away any part of it and still have a useful OO system.

&gt;— Hadley Wickham, Advanced R

.footnote[
* S3 should not be confused with R's other object oriented systems: &lt;br/&gt;S4, Reference classes, and R6*.
]

---

## What's going on?

S3 objects and their related functions work using a very simple dispatch mechanism - a generic function is created whose sole job is to call the `UseMethod` function which then calls a class specialized function using the naming convention: `generic.class`.

--

We can see all of the specialized versions of the generic using the `methods` function.


```r
methods("plot")
```

```
##  [1] plot.acf*           plot.data.frame*    plot.decomposed.ts*
##  [4] plot.default        plot.dendrogram*    plot.density*      
##  [7] plot.ecdf           plot.factor*        plot.formula*      
## [10] plot.function       plot.hclust*        plot.histogram*    
## [13] plot.HoltWinters*   plot.isoreg*        plot.lm*           
## [16] plot.medpolish*     plot.mlm*           plot.ppr*          
## [19] plot.prcomp*        plot.princomp*      plot.profile.nls*  
## [22] plot.R6*            plot.raster*        plot.spec*         
## [25] plot.stepfun        plot.stl*           plot.table*        
## [28] plot.ts             plot.tskernel*      plot.TukeyHSD*     
## see '?methods' for accessing help and source code
```

---

.small[

```r
methods("print")
```

```
##   [1] print.acf*                                          
##   [2] print.AES*                                          
##   [3] print.anova*                                        
##   [4] print.aov*                                          
##   [5] print.aovlist*                                      
##   [6] print.ar*                                           
##   [7] print.Arima*                                        
##   [8] print.arima0*                                       
##   [9] print.AsIs                                          
##  [10] print.aspell*                                       
##  [11] print.aspell_inspect_context*                       
##  [12] print.bibentry*                                     
##  [13] print.Bibtex*                                       
##  [14] print.browseVignettes*                              
##  [15] print.bslib_fragment*                               
##  [16] print.bslib_page*                                   
##  [17] print.by                                            
##  [18] print.cachem*                                       
##  [19] print.changedFiles*                                 
##  [20] print.check_bogus_return*                           
##  [21] print.check_code_usage_in_package*                  
##  [22] print.check_compiled_code*                          
##  [23] print.check_demo_index*                             
##  [24] print.check_depdef*                                 
##  [25] print.check_details*                                
##  [26] print.check_details_changes*                        
##  [27] print.check_doi_db*                                 
##  [28] print.check_dotInternal*                            
##  [29] print.check_make_vars*                              
##  [30] print.check_nonAPI_calls*                           
##  [31] print.check_package_code_assign_to_globalenv*       
##  [32] print.check_package_code_attach*                    
##  [33] print.check_package_code_data_into_globalenv*       
##  [34] print.check_package_code_startup_functions*         
##  [35] print.check_package_code_syntax*                    
##  [36] print.check_package_code_unload_functions*          
##  [37] print.check_package_compact_datasets*               
##  [38] print.check_package_CRAN_incoming*                  
##  [39] print.check_package_datalist*                       
##  [40] print.check_package_datasets*                       
##  [41] print.check_package_depends*                        
##  [42] print.check_package_description*                    
##  [43] print.check_package_description_encoding*           
##  [44] print.check_package_license*                        
##  [45] print.check_packages_in_dir*                        
##  [46] print.check_packages_used*                          
##  [47] print.check_po_files*                               
##  [48] print.check_pragmas*                                
##  [49] print.check_Rd_line_widths*                         
##  [50] print.check_Rd_metadata*                            
##  [51] print.check_Rd_xrefs*                               
##  [52] print.check_RegSym_calls*                           
##  [53] print.check_S3_methods_needing_delayed_registration*
##  [54] print.check_so_symbols*                             
##  [55] print.check_T_and_F*                                
##  [56] print.check_url_db*                                 
##  [57] print.check_vignette_index*                         
##  [58] print.checkDocFiles*                                
##  [59] print.checkDocStyle*                                
##  [60] print.checkFF*                                      
##  [61] print.checkRd*                                      
##  [62] print.checkRdContents*                              
##  [63] print.checkReplaceFuns*                             
##  [64] print.checkS3methods*                               
##  [65] print.checkTnF*                                     
##  [66] print.checkVignettes*                               
##  [67] print.citation*                                     
##  [68] print.cli_ansi_html_style*                          
##  [69] print.cli_ansi_string*                              
##  [70] print.cli_ansi_style*                               
##  [71] print.cli_boxx*                                     
##  [72] print.cli_diff_chr*                                 
##  [73] print.cli_doc*                                      
##  [74] print.cli_progress_demo*                            
##  [75] print.cli_rule*                                     
##  [76] print.cli_sitrep*                                   
##  [77] print.cli_spark*                                    
##  [78] print.cli_spinner*                                  
##  [79] print.cli_tree*                                     
##  [80] print.codoc*                                        
##  [81] print.codocClasses*                                 
##  [82] print.codocData*                                    
##  [83] print.colorConverter*                               
##  [84] print.compactPDF*                                   
##  [85] print.condition                                     
##  [86] print.connection                                    
##  [87] print.CRAN_package_reverse_dependencies_and_views*  
##  [88] print.css*                                          
##  [89] print.data.frame                                    
##  [90] print.Date                                          
##  [91] print.default                                       
##  [92] print.dendrogram*                                   
##  [93] print.density*                                      
##  [94] print.difftime                                      
##  [95] print.dist*                                         
##  [96] print.Dlist                                         
##  [97] print.DLLInfo                                       
##  [98] print.DLLInfoList                                   
##  [99] print.DLLRegisteredRoutines                         
## [100] print.document_context*                             
## [101] print.document_position*                            
## [102] print.document_range*                               
## [103] print.document_selection*                           
## [104] print.dummy_coef*                                   
## [105] print.dummy_coef_list*                              
## [106] print.ecdf*                                         
## [107] print.eigen                                         
## [108] print.factanal*                                     
## [109] print.factor                                        
## [110] print.family*                                       
## [111] print.fileSnapshot*                                 
## [112] print.findLineNumResult*                            
## [113] print.formula*                                      
## [114] print.fseq*                                         
## [115] print.ftable*                                       
## [116] print.function                                      
## [117] print.getAnywhere*                                  
## [118] print.glm*                                          
## [119] print.hashtab*                                      
## [120] print.hclust*                                       
## [121] print.help_files_with_topic*                        
## [122] print.hexmode                                       
## [123] print.HoltWinters*                                  
## [124] print.hsearch*                                      
## [125] print.hsearch_db*                                   
## [126] print.htest*                                        
## [127] print.html*                                         
## [128] print.html_dependency*                              
## [129] print.htmltools.selector*                           
## [130] print.htmltools.selector.list*                      
## [131] print.infl*                                         
## [132] print.integrate*                                    
## [133] print.isoreg*                                       
## [134] print.json*                                         
## [135] print.key_missing*                                  
## [136] print.kmeans*                                       
## [137] print.knitr_kable*                                  
## [138] print.Latex*                                        
## [139] print.LaTeX*                                        
## [140] print.libraryIQR                                    
## [141] print.listof                                        
## [142] print.lm*                                           
## [143] print.loadings*                                     
## [144] print.loess*                                        
## [145] print.logLik*                                       
## [146] print.ls_str*                                       
## [147] print.medpolish*                                    
## [148] print.MethodsFunction*                              
## [149] print.mtable*                                       
## [150] print.NativeRoutineList                             
## [151] print.news_db*                                      
## [152] print.nls*                                          
## [153] print.noquote                                       
## [154] print.numeric_version                               
## [155] print.object_size*                                  
## [156] print.octmode                                       
## [157] print.packageDescription*                           
## [158] print.packageInfo                                   
## [159] print.packageIQR*                                   
## [160] print.packageStatus*                                
## [161] print.pairwise.htest*                               
## [162] print.person*                                       
## [163] print.POSIXct                                       
## [164] print.POSIXlt                                       
## [165] print.power.htest*                                  
## [166] print.ppr*                                          
## [167] print.prcomp*                                       
## [168] print.princomp*                                     
## [169] print.proc_time                                     
## [170] print.quosure*                                      
## [171] print.quosures*                                     
## [172] print.R6*                                           
## [173] print.R6ClassGenerator*                             
## [174] print.raster*                                       
## [175] print.Rd*                                           
## [176] print.recordedplot*                                 
## [177] print.restart                                       
## [178] print.RGBcolorConverter*                            
## [179] print.rlang:::list_of_conditions*                   
## [180] print.rlang_box_done*                               
## [181] print.rlang_box_splice*                             
## [182] print.rlang_data_pronoun*                           
## [183] print.rlang_dict*                                   
## [184] print.rlang_dyn_array*                              
## [185] print.rlang_envs*                                   
## [186] print.rlang_error*                                  
## [187] print.rlang_fake_data_pronoun*                      
## [188] print.rlang_lambda_function*                        
## [189] print.rlang_message*                                
## [190] print.rlang_trace*                                  
## [191] print.rlang_warning*                                
## [192] print.rlang_zap*                                    
## [193] print.rle                                           
## [194] print.rlib_bytes*                                   
## [195] print.roman*                                        
## [196] print.sass*                                         
## [197] print.sass_bundle*                                  
## [198] print.sass_layer*                                   
## [199] print.SavedPlots*                                   
## [200] print.scalar*                                       
## [201] print.sessionInfo*                                  
## [202] print.shiny.tag*                                    
## [203] print.shiny.tag.env*                                
## [204] print.shiny.tag.list*                               
## [205] print.shiny.tag.query*                              
## [206] print.simple.list                                   
## [207] print.smooth.spline*                                
## [208] print.socket*                                       
## [209] print.srcfile                                       
## [210] print.srcref                                        
## [211] print.stepfun*                                      
## [212] print.stl*                                          
## [213] print.StructTS*                                     
## [214] print.subdir_tests*                                 
## [215] print.summarize_CRAN_check_status*                  
## [216] print.summary.aov*                                  
## [217] print.summary.aovlist*                              
## [218] print.summary.ecdf*                                 
## [219] print.summary.glm*                                  
## [220] print.summary.lm*                                   
## [221] print.summary.loess*                                
## [222] print.summary.manova*                               
## [223] print.summary.nls*                                  
## [224] print.summary.packageStatus*                        
## [225] print.summary.ppr*                                  
## [226] print.summary.prcomp*                               
## [227] print.summary.princomp*                             
## [228] print.summary.table                                 
## [229] print.summary.warnings                              
## [230] print.summaryDefault                                
## [231] print.table                                         
## [232] print.tables_aov*                                   
## [233] print.terms*                                        
## [234] print.ts*                                           
## [235] print.tskernel*                                     
## [236] print.TukeyHSD*                                     
## [237] print.tukeyline*                                    
## [238] print.tukeysmooth*                                  
## [239] print.undoc*                                        
## [240] print.vignette*                                     
## [241] print.warnings                                      
## [242] print.xfun_raw_string*                              
## [243] print.xfun_rename_seq*                              
## [244] print.xfun_strict_list*                             
## [245] print.xgettext*                                     
## [246] print.xngettext*                                    
## [247] print.xtabs*                                        
## see '?methods' for accessing help and source code
```
]

---


```r
print.factor
```

```
## function (x, quote = FALSE, max.levels = NULL, width = getOption("width"), 
##     ...) 
## {
##     ord &lt;- is.ordered(x)
##     if (length(x) == 0L) 
##         cat(if (ord) 
##             "ordered"
##         else "factor", "(0)\n", sep = "")
##     else {
##         xx &lt;- character(length(x))
##         xx[] &lt;- as.character(x)
##         keepAttrs &lt;- setdiff(names(attributes(x)), c("levels", 
##             "class"))
##         attributes(xx)[keepAttrs] &lt;- attributes(x)[keepAttrs]
##         print(xx, quote = quote, ...)
##     }
##     maxl &lt;- if (is.null(max.levels)) 
##         TRUE
##     else max.levels
##     if (maxl) {
##         n &lt;- length(lev &lt;- encodeString(levels(x), quote = ifelse(quote, 
##             "\"", "")))
##         colsep &lt;- if (ord) 
##             " &lt; "
##         else " "
##         T0 &lt;- "Levels: "
##         if (is.logical(maxl)) 
##             maxl &lt;- {
##                 width &lt;- width - (nchar(T0, "w") + 3L + 1L + 
##                   3L)
##                 lenl &lt;- cumsum(nchar(lev, "w") + nchar(colsep, 
##                   "w"))
##                 if (n &lt;= 1L || lenl[n] &lt;= width) 
##                   n
##                 else max(1L, which.max(lenl &gt; width) - 1L)
##             }
##         drop &lt;- n &gt; maxl
##         cat(if (drop) 
##             paste(format(n), ""), T0, paste(if (drop) 
##             c(lev[1L:max(1, maxl - 1)], "...", if (maxl &gt; 1) lev[n])
##         else lev, collapse = colsep), "\n", sep = "")
##     }
##     if (!isTRUE(val &lt;- .valid.factor(x))) 
##         warning(val)
##     invisible(x)
## }
## &lt;bytecode: 0x0000025a6346a1c0&gt;
## &lt;environment: namespace:base&gt;
```
---


```r
print.integer
```

```
## Error in eval(expr, envir, enclos): object 'print.integer' not found
```

--

.pad-top[]


```r
print.default
```

```
## function (x, digits = NULL, quote = TRUE, na.print = NULL, print.gap = NULL, 
##     right = FALSE, max = NULL, width = NULL, useSource = TRUE, 
##     ...) 
## {
##     args &lt;- pairlist(digits = digits, quote = quote, na.print = na.print, 
##         print.gap = print.gap, right = right, max = max, width = width, 
##         useSource = useSource, ...)
##     missings &lt;- c(missing(digits), missing(quote), missing(na.print), 
##         missing(print.gap), missing(right), missing(max), missing(width), 
##         missing(useSource))
##     .Internal(print.default(x, args, missings))
## }
## &lt;bytecode: 0x0000025a5e8b9240&gt;
## &lt;environment: namespace:base&gt;
```

---

## The other way

If instead we have a class and want to know what specialized functions exist for that class, then we can again use the `methods` function with the `class` argument.


```r
methods(class="factor")
```

```
##  [1] [             [[            [[&lt;-          [&lt;-           all.equal    
##  [6] as.character  as.data.frame as.Date       as.list       as.logical   
## [11] as.POSIXlt    as.vector     c             coerce        droplevels   
## [16] format        initialize    is.na&lt;-       length&lt;-      levels&lt;-     
## [21] Math          Ops           plot          print         relevel      
## [26] relist        rep           show          slotsFromS3   summary      
## [31] Summary       xtfrm        
## see '?methods' for accessing help and source code
```

---

## Adding methods



.pull-left[

```r
x = structure(c(1,2,3), class="class_A")
x
```

```
## [1] 1 2 3
## attr(,"class")
## [1] "class_A"
```
]

.pull-right[

```r
y = structure(c(6,5,4), class="class_B")
y
```

```
## [1] 6 5 4
## attr(,"class")
## [1] "class_B"
```
]

--

&lt;div&gt;
.pull-left[

```r
print.class_A = function(x) {
  cat("Class A!\n")
  print.default(unclass(x))
}

x
```

```
## Class A!
## [1] 1 2 3
```
]

.pull-right[

```r
print.class_B = function(x) {
  cat("Class B!\n")
  print.default(unclass(x))
}

y
```

```
## Class B!
## [1] 6 5 4
```
]
&lt;/div&gt;

--

&lt;div&gt;
.pull-left[

```r
class(x) = "class_B"
x
```

```
## Class B!
## [1] 1 2 3
```
]

.pull-right[

```r
class(y) = "class_A"
y
```

```
## Class A!
## [1] 6 5 4
```
]
&lt;/div&gt;

---

## Defining a new S3 Generic


```r
shuffle = function(x) {
  UseMethod("shuffle")
}
```

--


```r
shuffle.default = function(x) {
  stop("Class ", class(x), " is not supported by shuffle.\n", call. = FALSE)
}
```

--


```r
shuffle.factor = function(f) {
  factor( sample(as.character(f)), levels = sample(levels(f)) )
}

shuffle.integer = function(x) {
  sample(x)
}
```

--

.pull-left[

```r
shuffle( 1:10 )
```

```
##  [1]  9  1  5  6  8  7 10  4  3  2
```

```r
shuffle( factor(c("A","B","C","A")) )
```

```
## [1] B A C A
## Levels: A C B
```
]

.pull-right[

```r
shuffle( c(1, 2, 3, 4, 5) )
```

```
## Error: Class numeric is not supported by shuffle.
```

```r
shuffle( letters[1:5] )
```

```
## Error: Class character is not supported by shuffle.
```
]

---

## Exercise 2 - classes, modes, and types

Below we have defined an S3 method called `report`, it is designed to return a message about the type/mode/class of an object passed to it.

.pull-left[

```r
report = function(x) {
  UseMethod("report")
}

report.default = function(x) {
  "This class does not have a method defined."
}
```
]

.pull-right[

```r
report.integer = function(x) {
 "I'm an integer!"
}

report.double = function(x) {
  "I'm a double!"
}

report.numeric = function(x) {
  "I'm a numeric!"
}
```
]

.pad-top[
Try running the `report` function with different input types, what happens? &lt;br/&gt; 
Now run `rm("report.integer")` in your console and try using the `report` &lt;br/&gt;
function  again, what has changed? What does this tell us about S3, types, modes, &lt;br/&gt; 
and classes?
]


---

## Acknowledgments

Above materials are derived in part from the following sources:

* Hadley Wickham - [Advanced R](http://adv-r.had.co.nz/)
* [R Language Definition](http://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
