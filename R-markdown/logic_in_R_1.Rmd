---
title: "Basics of R"
author: "Jyotishka Datta"
date: "2020/01/24 (updated: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
  css: mystyle.css
lib_dir: libs
nature:
  highlightStyle: github
highlightLines: true
countIncrementalSlides: false
---

```{r, message=FALSE, warning=FALSE, include=FALSE}
options(
  htmltools.dir.version = FALSE, # for blogdown
  width=80
)

# library(emo)
htmltools::tagList(rmarkdown::html_dependency_font_awesome())
```

---
class: middle
count: false

# (Almost) Everything is a Vector

---
  
## Types of vectors
  
  The fundamental building block of data in R are vectors (collections of related values, objects, other data structures, etc).

<br/>
  
  R has two fundamental vector classes:
  
  * Vectors (atomic vectors) 

- collections of values that are all of the *same* type (e.g. all logical values, all numbers, or all character strings).

* Lists (generic vectors)

- collections of *any* type of R object, even other lists (meaning they can have a hierarchical/tree-like structure).

---
  
## Atomic Vectors
  
  R has six atomic vector types: 
  
|  typeof    |   mode    | storage.mode 
|:-----------|:----------|:-------------
| logical    | logical   | logical      
| double     | numeric   | double       
| integer    | numeric   | integer      
| character  | character | character    
| complex    | complex   | complex      
| raw        | raw       | raw          

<br/>
  
For now we'll mainly worry about the first type, we'll discuss the following three next time (last two almost never come up).

---
count: false

# Conditionals

---
  
  ## Logical (boolean) operations
  
|  Operator  |  Operation    |  Vectorized? 
|:-----------|:--------------|:-------------
| <code>x &#124; y</code>    |  or           |   Yes        
| `x & y`    |  and          |   Yes        
| `!x`       |  not          |   Yes        
| <code>x &#124;&#124; y</code> |  or           |   No         
| `x && y`   |  and          |   No         
|`xor(x,y)`  |  exclusive or |   Yes        


---
class: split-50

## Vectorized?

```{r}
x = c(TRUE,FALSE,TRUE)
y = c(FALSE,TRUE,TRUE)
```

.pull-left[
```{r}
  x | y
  x || y
 ```
]

.pull-right[
```{r}
  x & y
  x && y
 ```
]


---
class: split-50

## Length coercion

```{r}
x = c(TRUE,FALSE,TRUE)
y = c(TRUE)
z = c(FALSE,TRUE)
```

.pull-left[
```{r}
  x | y
  y | z
  ```
]

.pull-right[
 ```{r}
  x & y
  y & z
  ```
]

```{r}
x | z
```

---
  
## Comparisons
  
 Operator  |  Comparison                |  Vectorized?
:-----------|:---------------------------|:-----------------
`x < y`    |  less than                 |  Yes
`x > y`    |  greater than              |  Yes
`x <= y`   |  less than or equal to     |  Yes
`x >= y`   |  greater than or equal to  |  Yes
`x != y`   |  not equal to              |  Yes
`x == y`   |  equal to                  |  Yes
`x %in% y` |  contains                  |  Yes (for `x`)


---
class: split-50

## Comparisons

```{r}
x = c("A","B","C")
z = c("A")
```

.pull-left[
```{r}
  x == z
  x != z
  x > z
```
]

.pull-right[
```{r}
  x %in% z
  z %in% x
```
]

---
  
## Conditional Control Flow
  
Conditional execution of code blocks is achieved via `if` statements. 

*Note that `if` statements are **not** vectorized.*
  
```{r}
x = c(3,1)

if (3 %in% x)
  "Here!"
if (x >= 2)
  "Now Here!"
```

---
class: split-50

## Collapsing logical vectors

There are a couple of helper functions for collapsing a logical vector down to a single value: `any`, `all`

```{r}
x = c(3,4)
```

.pull-left[
```{r}
  any(x >= 2)
  all(x >= 2)
```
]

.pull-right[
```{r}
  !any(x >= 2)
  if (any(x >= 2))
    print("Now There!")
```
]


---
  
## Nesting Conditionals
  
```{r}
x = 3
if (x < 0) {
  "Negative"
} else if (x > 0) {
  "Positive"
} else {
  "Zero"
}
```

```{r}
x = 0
if (x < 0) {
  "Negative"
} else if (x > 0) {
  "Positive"
} else {
  "Zero"
}
```

---
class: middle
count: false

# Error Checking

---
  
## `stop` and `stopifnot`
  
Often we want to validate user input or function arguments - if our assumptions are not met then we often want to report the error and stop execution. 

```{r error=TRUE}
ok = FALSE
if (!ok)
  stop("Things are not ok.")

stopifnot(ok)
```

*Note - an error (like the one generated by `stop`) will prevent an RMarkdown document from compiling unless `error=TRUE` is set for that code block.*
  
---
  
## Style choices
  
```{r eval=FALSE}
# Do stuff
if (condition_one) {
  ##
  ## Do stuff
  ##
} else if (condition_two) {
  ##
  ## Do other stuff
  ##
} else if (condition_error) {
  stop("Condition error occured")
}
```

---
  
## Style choices

```{r eval=FALSE}
# Do stuff better
if (condition_error) {
  stop("Condition error occured")
}

if (condition_one) {
  ##
  ## Do stuff
  ##
} else if (condition_two) {
  ##
  ## Do other stuff
  ##
}
```

### Ultimately, it's subjective !

---
  
## Exercise 1
  
  Write a set of conditional(s) that satisfies the following requirements,

* If `x` is greater than 3 and `y` is less than or equal to 3 then print "Hello world!"

* Otherwise if `x` is greater than 3 print "!dlrow olleH"

* If `x` is less than or equal to 3 then print "Something else ..."

* Stop execution if x is odd and y is even and report an error, don't print any of the text strings above.


Test out your code by trying various values of `x` and `y`.


---
class: middle
count: false

# Loops

---

## `for` loops

Simplest, and most common type of loop in R - given a vector iterate through the elements and evaluate the code block for each.


```{r}
for(x in 1:10)
{
  cat(x^2,"")
}
```

```{r}
for(y in list(1:3, LETTERS[1:7], c(TRUE,FALSE)))
{
  cat(length(y),"")
}
```

---

## `while` loops

Repeat until the given condition is **not** met (i.e. evaluates to `FALSE`)

```{r}
i = 1
res = rep(NA,10)

while (i <= 10) {
  res[i] = i^2
  i = i+1
}

res
```

---

## `repeat` loops

Repeat until `break`

```{r}
i = 1
res = rep(NA,10)

repeat {
  res[i] = i^2
  i = i+1
  if (i > 10)
    break
}

res
```

---
class: split-50

## Special keywords - `break` and `next`

These are special actions that only work *inside* of a loop

* `break` - ends the current *loop* (inner-most)
* `next` - ends the current *iteration*

.pull-left[
```{r}
for(i in 1:10) {
    if (i %% 2 == 0)
        break
    cat(i,"")
}
```
]

.pull-right[
```{r}
for(i in 1:10) {
    if (i %% 2 == 0)
        next
    cat(i,"")
}
```
]


---
class: split-50

## Some helper functions

Often we want to use a loop across the indexes of an object and not the elements themselves. There are several useful functions to help you do this: `:`, `length`, `seq`, `seq_along`, `seq_len`, etc.

```{r}
4:7
seq(4,7,by=1)
seq_along(4:7)
seq_len(length(4:7))
```

---

## Exercise 2

Below is the list of primes between 2 and 100:
```
2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 
43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97
```

If you were given the vector `x = c(3, 4, 12, 19, 23, 48, 50, 61, 63, 78)`, write out the R code necessary to print only the values of `x` that are *not* prime (without using subsetting or the `%in%` operator). 

Your code should use *nested* loops to iterate through the vector of primes and `x`.

---
class: middle
count: false

# Functions

---

## When to use functions

The goal of a function should be to encapsulate a *small* *reusable* piece of code.

* Name should make it clear what the function does (think in terms of simple verbs).

* Functionality should be simple enough to be quickly understood.

* The smaller and more modular the code the easier it will be to reuse elsewhere.

* Better to change code in one location than code everywhere.

---
class: middle, bottom, segue


## Next we will look at functions.

---
## Functions 

- Functions are blocks of code that allows R to be modular and facilitate code reuse.
- An R programmer can define their own functions as follows:
```{r, echo = TRUE, eval = FALSE}
function_name <- function([arg1], [arg2], ...){
#function code body
}
```
- The function arguments are optional. Function arguments are the variables passed
to the function, used by the function's code to perform calculations. A function can take no arguments.
- A function can also return any R primitive or object using the return(object)
statement.

---
## Examples 

-  Examples of two different functions 

```{r, echo = TRUE, eval = FALSE}
# computes the mean of a vector of numbers
mean <- function(a_vector) {
s <- sum(a_vector)
x <- s/length(a_vector)
}
```

```{r, echo = TRUE, eval = FALSE}
# checks to see if a string s starts with letter x
startsWith <- function(x, s){
if(x == substr(s, 0, 1){
return(TRUE)
}
return(FALSE)
}
```

---
## Anatomy of a function

-  **Default arguments**
-  Function arguments can be assigned default values as follows:
```{r, echo = TRUE, eval = FALSE}
sort_vector <- function(a_vector, ascending=TRUE){
# sorting algorithm
}
```
- When calling this function, the arguments given default values do not need to be specified. In this case, the defaults are used.
- Example:
```{r, echo = TRUE, eval = FALSE}
sort_vector(a_vector) # returns a_vector in ascending order
sort_vector(a_vector, FALSE) # returns a vector in descending order
```

---
## "Scope" of a variable 

-  Variable Scoping
-  Variables that are bound to an R primitive or object outside a function are called global variables, and are accessible everywhere in an R program.
-  Example:
```{r, echo = TRUE}
x <- 5
test <- function() {
cat(x + 5)
}
test(); 
```

- Here 'x' is a "GLOBAL" variable - accessible from anywhere. 
---

## "Scope" (contd.)

-  Variables bound inside a function are only accessible within that function. These are called local variables. Example:
```{r, echo = TRUE}
x <- 10
test <- function() {
x <- 5
cat(x + 20)
}
test() #prints 25
cat(x + 20) #prints 30
```
-  **Note that the local variable assignment takes precedence inside the function test over the global assignment**.
---
## Side effects 

-  R functions have no side effects-- they cannot change the value of global variables. Example:
```{r, echo =  TRUE}
x <- 10
test <- function(z) {
z <- z + 10
cat(z)
}
test(x) #prints 20
cat(x) #prints 10
```
-  **Note that x is still bound to 10 outside of test()**.

---
# Acknowledgments

Above materials are derived in part from the following sources:
  
* Colin Rundell's slides. 
* Hadley Wickham - [Advanced R](http://adv-r.had.co.nz/)
* [R Language Definition](http://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html)

